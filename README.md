# Android-Malware-Application-Detection
Model to detect Malicious Android applications. Bachelors Final year portfolio project at IIT(ISM) Dhanbad. 

In order to address this problem of fraudent appliocations, I created a framework ingrained on Deep Learning Techniques. The first step of implementation involves extracting three types of features by statically analyzing Android apps. Then, in the second step we pass the three types of features through three separate deep learning models to learn the features. Finally, the learnt features are passed through another deep learning model which performs the task of predicting whether the app under consideration is a malicious application or benign in nature. Our framework was able to learn patterns to detect malware and benign. We performed our experiment with 2300 malware and 1500 benign apps and our Deep Learning model has achieved an F1-score of 99% and it outperforms several existing malware detection approaches. Also the proposed framework is very efficient and it can easily be scaled to perform large scale Android MalwareDetection.

Algorithm:

DNN-1 (Permission Vector)
	•	Permissions_list [ 5821, 504]
	•	output_list[ 5821,1]
	•	m = 504
	•	iterations = 20
	•	W = random(m,1)
	•	a = Permissions_list
	•	for i in iterations do until step 13
	•	n = number of layers  //Forward Propogation
	•	for j in n do until step 11
	•	Z = W(transpose)*a + b
	•	a = max(0,Z)  //ReLu activation function
	•	W = W – k*dW  //BackPropagation
	•	b  = b – k*db
Result: a[ 5821,64]
CNN (opcode sequences)
Input: opcode sequence
Output: Vector representing semantic relationship between opcodes

	•	O = [o1,o2,o3,…..,on]  n=100000     //Embedding
	•	X[218,100000]   // one hot vector sequence of the application
	•	for i in n do until step 8
	•	X[][i] = [0]
	•	for j in (0,218) do until step 8
	•	if O[i] = opcode[j]
	•	X[j][i] = 1
	•	filters = 32   // first CNN layer 32 filters 64 filters 128 filters
	•	a[100000][filters]
	•	for i in filters do until step 16
	•	W binary random 3*3 matrix
	•	for j in (0,100000) do until step 16:
	•	c = count(X.columns)
	•	for k in (0,c) do until step 14:
	•	z = X[j,j+3][k,k+3] * W
	•	Z = sum(z)   // Sum of elements in z matrix
	•	a[j][i] = Z
	•	X = a
	•	if filters != 128 do until step 19
	•	filters = filters*2
	•	goto step 9
	•	else break
	•	R[1,128] = [0]
	•	for i in filters do until step
	•	x = max(X[][i])
	•	R[1][i] = x
Result: R [1, 128] for one application for 5821 applications R [5821,125]
DNN-2 (API calls)
	•	API calls_list [ 5821, 66]
	•	output_list[ 5821,1]
	•	m = 66
	•	iterations = 20
	•	W = random(m,1)
	•	a = API calls_list
	•	for i in iterations do until step 13
	•	n = number of layers  // n = 3
	•	for j in n do until step 11
	•	Z = W(transpose)*a + b
	•	a = max(0,Z)  //ReLu activation function
	•	W = W – k*dW  //BackPropagation
	•	b  = b – k*db
Result: a [ 5821,64]

DNN-3 (Final network)
	•	input [5821,256]  //Initialize input vector
	•	input = DNN1+ CNN + DNN2
	•	iterations = 20
	•	W = random(m,1)
	•	a = input
	•	for i in iterations do until step 12
	•	n = number of layers  // n = 2
	•	for j in n do until step 11
	•	Z = W(transpose)*a + b
	•	a = max(0,Z)  //ReLu activation function
	•	W = W – k*dW  //BackPropagation
	•	b  = b – k*db
Result: a (0>=a>=1) if(a>0.5) app is goodware else malware

Presentation: https://docs.google.com/presentation/d/121--plpEiRz0E3PbvqYTudkpBdrlqn6A/edit?usp=sharing&ouid=110659274553340739177&rtpof=true&sd=true

